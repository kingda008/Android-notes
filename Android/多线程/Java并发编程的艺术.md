上下文切换：即使单核处理器也支持多线程，CPU给每个线程分配CPU时间片来实现。切换前保存上一个任务的状态，一边下次切换回这个任务时，可以再加载这个状态。任务从保存到再加载的过程就是一次上下文切换。



多线程一定快吗？

![image-20220308162625194](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220308162625194-16467279874931.png)

因为上下文的切换和线程创建都需要开销。



拓展：

1，一个进程中的多个线程会是只能在同一个内核中运行吗？进程，线程，多核CPU的关系，调度策略

2，单核的情况下，排除被调度到其他进程；那么是不是串行其实是最快的？ 增加线程和设置线程的优先级只是增加了进程在所有系统的占比？



Lmbench3可以测量上下文切换的时长

vmstat 可以测量上下文次数



如何减少上下文切换

无锁并发编程（竞争锁会引起上下文切换），CAS算法，使用最少线程和使用协程







避免死锁的几个常见方法：
1，避免一个线程同时获取多个锁

2，避免一个线程在锁内占用多个资源，尽量保证每个锁只占用一个资源

3，尝试使用定时锁 ，使用 lock.tryLock(timeout)来替代内部锁机制

4，数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。









## 资源限制

程序的执行速度受限于计算机硬件资源或软件资源。比如服务器带宽只有2M，某个资源下载速度是1M，系统即使开10个线程，下载速度也不会变成10M。并发时要考虑这些限制因素。限制有带宽的上传下载速度，硬盘读写速度和CPU处理速度。

​		软件资源的限制有数据库的连接数和socket连接数等

​		有时候开的线程越多越慢，内存和cpu都会占用。





# Java并发机制的底层实现原理

​		Java代码编译成字节码，字节码被类加载器加载的JVM中，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，所以Java的并发机制依赖于JVM的实现和CPU指令

​	

​		

## volatile的应用

​		轻量级synchronized。保证了共享变量的 可见性；一个线程修改共享变量时，另一个线程能读到这个修改的值。比synchronized执行成本更低，因为它不会引起线程上下文切换和调度。

​		如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量时一致的。

​		先了解下CPU术语：

![image-20220309084950744](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309084950744-16467869924652.png)





### volatile是如何保证可见性呢？

以X86举例，volatile变量转成汇编如下：


![image-20220309090451556](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309090451556.png)

查看对应cpu手册可知，Lock前缀的指令在多核处理器下会引发两件事情：

**1，将当前处理器缓存行的数据写回系统内存**

​        普通情况下cpu不直接和内存通信，而是将内存中的数据读取到内部缓存（L1,L2等）后再进行操作。但是操作完不知道何时写回内存。但是加上Lock之后会立马写回内存（缓存锁定：锁定内存，写回内存）。缓存一致性会阻止同时修改由两个以上的处理器缓存的内存区域数据

**2，这个写回操作同时会使其他CPU缓存的该内存地址变成无效**

​       多核处理器下，为了保证处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探总线上的数据检查自己缓存的值是不是过期了，如果过期了就会将自己的缓存行设置成无效状态。当处理器使用这个数据时会重新从内存中读取。











## synchronized的实现原理



**对于普通方法，锁的是当前实例对象**

**对于静态方法，锁的是当前类的Class对象**

**对于方法块，锁的括号中配置的对象**



JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。代码块同步是使用monitorenter和monitorexit指令实现的。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁。



## 对象头

synchronized用的锁存在Java对象头里。

![image-20220309100341072](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309100341072.png)



![image-20220309100408602](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309100408602.png)



## 锁的升级

级别从低到高依次是：无锁状态，偏向锁，轻量级锁，重量级锁。**锁只能升级不能降级**



**偏向锁获取**

大多数就情况下，锁是不存在竞争的，总是由同一个线程多次获得。为了让锁的代价更低引入了偏向锁。

1，当一个线程访问同步块获取锁的时，会在对象头和栈帧中的所记录里存储锁偏向的线程ID,

2，以后该线程进入和退出同步块时不需要进行CAS操作来枷锁和解锁，只需要简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。

​        如果成功，表示线程已经获得了锁。

3，失败则需要继续测试下Mark Word偏向锁的标识是否设置成1（表示当前是偏向锁）；如果没有设置，则使用CAS竞争锁；

4，如果设置了，则使用CAS尝试将对象头的偏向锁指向当前线程



**偏向锁撤销**

使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁

1，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有在执行的字节码）。他会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着。如果线程不处于活动状态，则将对象头设置成无锁状态；

2，如果线程仍活着，持有偏向锁的栈会被执行，遍历偏向对象的锁记录和对象头的Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。



做这些的是虚拟机而不是线程？

安全点是指虚拟机的安全点，而不是线程的安全点？

![image-20220309104638595](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309104638595-16467939998101.png)

 ![image-20220309104745130](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309104745130-16467940664533.png)







**在可以使用JVM参数来关闭偏向锁功能**





### 轻量级锁

**加锁**

线程执行同步块前，**JVM**会先在当前线程栈帧中创建用于存储锁记录的空间，并将对象中的头Mark Word复制到锁记录中。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，失败表示其他线程在竞争，当前线程尝试使用自旋来获取锁。



“然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针” 结合Mark Word不同锁的不同内容好好体会下。



**解锁（解开获取的意思，不是撤销的意思）**



轻量级解锁时，会使用CAS将栈帧中的锁记录替换回对象头，如果成功，则表示没有竞争发生。失败则表示存在竞争，就会膨胀成重量级锁。



理解：前面的加锁是第一次执行，遇到同步块时虚拟机会在栈中创建锁记录。后面如果再次执行到同步块的时候则会进入到解锁过程。





![image-20220309112757346](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309112757346-16467964788914.png)

![image-20220309112815574](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309112815574-16467964967955.png)





**因为自旋会消耗CPU，为避免无用自旋（比如获得锁的线程被阻塞住了），一旦升级为重量级锁，就不会再恢复到轻量级锁的状态。当锁处于这个状态时，其他线程试图获取锁时都会被阻塞。持有锁的线程释放之后会唤醒这些线程，被唤醒的线程会进行新一轮的锁竞争**

理解：已经膨胀到了重量级了，所以意味着该段同步块容易被竞争，干脆别降级了





![image-20220309113049835](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309113049835-16467966511576.png)



## 原子操作

原子操作：不可被中断的一个或一序列操作。

![image-20220309145043410](Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF.assets/image-20220309145043410-16468086446677.png)



### 处理器是如何实现原子操作

32位IA-32处理器是基于 对缓存加锁和总线加锁 的方式来实现处理器之间的原子操作。





Java是通过锁和循环CAS的方式来实现原子操作。CAS正式利用了处理器提供的CMPXCHG指令实现的。

CAS原子操作3个问题：
1，ABA问题；通过增加版本号解决

2，循环时间cpu开销大。

3，只能保证一个共享变量的院子操作。可以将多个变量放到一块，AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里进行CAS





# 内存模型

























