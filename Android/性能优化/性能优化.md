

 

# anr

应用程序的响应性是由Activity Manager 和 WindowManager系统服务监听的。

问题：原理是什么？

![image-20210213152419400](image-20210213152419400.png)



# OOM

当前占用的内存加上我们申请的内存资源超过了 Dalvik虚拟机的最大内存限制就会抛出的Out of memory异常

**内存溢出/内存抖动/内存泄漏**



bitmapFactory的方法都是通过jni方法实现的，所以bitmap加载到内存是包含了Java和C两部分的

bitmap对象可以由虚拟机释放，但是c那部分的资源虚拟机是无法释放的，必须调用recycle来释放。



#### bitmap recycle

```
 /**
     * Free the native object associated with this bitmap, and clear the
     * reference to the pixel data. This will not free the pixel data synchronously;
     * it simply allows it to be garbage collected if there are no other references.
     * The bitmap is marked as "dead", meaning it will throw an exception if
     * getPixels() or setPixels() is called, and will draw nothing. This operation
     * cannot be reversed, so it should only be called if you are sure there are no
     * further uses for the bitmap. This is an advanced call, and normally need
     * not be called, since the normal GC process will free up this memory when
     * there are no more references to this bitmap.
     */
    public void recycle() {
        if (!mRecycled && mNativePtr != 0) {
            if (nativeRecycle(mNativePtr)) {
                // return value indicates whether native pixel object was actually recycled.
                // false indicates that it is still in use at the native level and these
                // objects should not be collected now. They will be collected later when the
                // Bitmap itself is collected.
                mNinePatchChunk = null;
            }
            mRecycled = true;
        }
    }
```

会释放和bitmap有关的native对象，同时会清理数据对象的引用。并不是立即清理，只是通知垃圾回收器。不可逆操作。可以不主动调用，垃圾回收期会处理。

#### LRU

最近最少使用



#### UI卡顿

60fps -> 16ms

overdraw 大量重叠

![image-20210213185903451](image-20210213185903451.png)

![image-20210213190056033](image-20210213190056033.png)

![image-20210213190322403](image-20210213190322403.png)



#### 内存泄漏

常见内存泄漏：

1，单例

2，匿名内部类

3，handler

4，避免使用static变量（如果进程常驻，那么会增加进程的内存使用，且容易被回收）

5，资源未关闭造成的内存泄漏

6，Asynctask造成的内存泄漏



#### 内存管理

 ![image-20210213191230554](image-20210213191230554.png)













# 启动优化

adb shell dumpsys activity activities 查看当前运行activity名字

黑，白屏问题：

默认主题中有 <item name="android:windowBackground">@color/background_material_light</item>

京东，淘宝等都是把这个背景属性设置为京东，淘宝的图片。



1.在自己的<style name="AppTheme" parent="Theme.AppCompat.Light">中加入windowsbackground
2.设置windowbackground为透明的  <item name="android:windowIsTranslucent">true</item>

QQ中的用法   
<item name="android:windowDisablePreview">true</item>
<item name="android:windowBackground">@null</item>



启动时间的查看 

4.4版本以前：

 adb shell am start -W com.lqr.wechat/com.lqr.wechat.activity.SplashActivity

ThisTime:最后一个启动的Activity的启动耗时；
TotalTime:自己的所有Activity的启动耗时；
WaitTime: ActivityManagerService启动App的Activity时的总时间（包括当前Activity的onPause()和自己Activity的启动）。

![image-20210523192741138](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523192741138.png)

![image-20210523192939603](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523192939603.png)



Am.java   946行开始打印启动时间信息
其中一个result对象，在871行初始化 result = mAm.startActivityAndWait(。。。）
在这个初始化时就已经进行了时间的计算：
在android-src\android-6.0.1_r1\frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java文件中计算
void windowsDrawnLocked() --->reportLaunchTimeLocked(SystemClock.uptimeMillis())中完成时间的统计;







4.4版本以后：

将启动时间放在固定目录，使用虚拟机自带方法 ，不用自己一个个System.currentTime 相减得到

```
public class App extends Application {
    @Override
 @Override
    public void onCreate() {
        super.onCreate();
        File file = new File(Environment.getExternalStorageDirectory(), "app1.trace");
        Log.i(TAG, "onCreate: " + file.getAbsolutePath());
        //把分析结果存在一个文件
        Debug.startMethodTracing(file.getAbsolutePath());
        //对全局属性赋值
        mContext = getApplicationContext();
        mMainThread = Thread.currentThread();
        mMainThreadId = android.os.Process.myTid();
        mMainLooper = getMainLooper();
        mHandler = new Handler();
        //因为LQRUIKit中已经对ImageLoader进行过初始化了
//        initImageLoader(getApplicationContext());
        new Thread(){
            @Override
            public void run() {
                //如果要用线程来节约了这些初始化的时间
                //1.里面的API不能去创建handler
                //2.不能有UI操作
                //3.对异步要求不高
                initNim();
                initImagePicker();
                initOkHttp();//可以懒加载
            }
        }.start();
        NIMClient.init(this, loginInfo(), options());
        Debug.stopMethodTracing();
    }

}
```

把文件拖进来



![image-20210523183103640](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523183103640.png)

滑动左上角可以选择查看信息范围。

thread 表示多少个进程？

![image-20210523191747427](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523191747427.png)

看到一层层方法调用的时间。右边有详细的时间统计

![image-20210523192121545](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523192121545.png)



优化方案：
1.开线程     没建handler    没操作UI   对异步要求不高
2.懒加载     用到的时候再初始化，如网络，数据库操作







# UI绘制优化：

![image-20210523200839557](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523200839557.png)

![image-20210523201148684](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523201148684.png)







![image-20210523200942989](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523200942989.png)

![image-20210523201016411](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523201016411.png)

16 毫秒的时间主要被两件事情所占用
第一件：将 UI 对象转换为一系列多边形和纹理（ 1 ）（？）
第二件： CPU 传递处理数据到 GPU 。所以很明显，我们要缩短
这两部分的时间，也就是说需要尽量减少对象转换的次数，以及上
传数据的次数 （？ 布局 自定义）



  

如何减少这两部分的时间 以至于在 16ms 完成呢  

CPU 减少 xml 转换成对象的时间
GPU 减少重复绘制的时间

![image-20210523201354808](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523201354808.png)



![image-20210523201437514](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523201437514.png)



![image-20210523201536639](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523201536639.png)



![image-20210523201600131](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523201600131.png)

![image-20210523201614697](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523201614697.png)

## 处理方法：

### 1，减少背景重复：

1.1 注意主题中的设置 ：

去掉单个activity的主题设置的属性
可以在setContentView之前getWindow().setBackgroundDrawable(null);

去掉所有activity主题设置中的属性
直接在styles.xml中设置<item name="android:windowBackground">@null</item>

1.2 非业务需要，不要去设置背景

## 2.使用裁减减少控件之间的重合部分

## 3，Android7.0之后系统做出的优化

invalidate()不再执行测量和布局动作



## 注意点：

1.能在一个平面显示的内容，尽量只用一个容器
2.尽可能把相同的容器合并merge
3.能复用的代码，用include处理，可以减少GPU重复工作



## 工具

Android/sdk/tools/bin/ui    automator   viewer.bat

Android\sdk\tools\monitor.bat

Device Monitor窗口中Hierarchy view

**三个点也是代表着View的Measure, Layout和Draw。**
绿: 表示该View的此项性能比该View Tree中超过50%的View都要快；例如,代表Measure的是绿点,意味着这个视图的测量时间快于树中的视图对象的50%。
黄: 表示该View的此项性能比该View Tree中超过50%的View都要慢； 
红: 表示该View的此项性能是View Tree中最慢的；。







![image-20210523202752952](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523202752952.png)

Android studio 运行APP ，选择 tools -> layout inspector

这里比较直观的看布局结构，方便发现问题，进行调优



第二种方法：

![image-20210523203309429](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523203309429.png)



经验 ，如果上一个节点只有一个，下一个节点也只有一个，那么就可以考虑是否可以删除一个嵌套，你懂的

![image-20210523203534662](%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/image-20210523203534662.png)

























