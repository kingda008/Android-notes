# 百度 App 网络深度优化系列（一）：DNS 优化



## 一、前言

网络优化是客户端几大技术方向中公认的一个深度领域，所以百度 App 给大家带来网络深度优化系列文章，其中包含系列《一》DNS 优化，系列《二》连接优化，系列《三》弱网优化，希望对大家在网络方向的学习和实践有所帮助。



百度起家于搜索，整个公司的网络架构和部署都是基于标准的 internet 协议，目前已经是全栈 HTTPS，来到移动互联网时代后，总的基础架构不变，但在客户端上需要做很多优化工作。



DNS（Domain Name System），它的作用是根据域名查出 IP 地址，它是 HTTP 协议的前提，只有将域名正确的解析成 IP 地址后，后面的 HTTP 流程才能进行，所以一般做网络优化会首选优化 DNS。



## 二、背景

DNS 优化核心需要解决的问题有两点：



【1】由于 DNS 劫持或故障造成的服务不可用，进而影响用户体验，影响公司的收入。



【2】由于 DNS 调度不准确导致的性能退化，进而影响用户体验。



百度 App 承载着亿级流量，每年都会遇到运营商 DNS 劫持或运营商 DNS 故障，整体影响非常不好，所以 DNS 优化刻不容缓，通过下图会更直观的了解运营商劫持或故障的原理。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/c8ce26fbaa526000523b6c98c3a285b5.jpg)



运营商劫持或故障的原理



## 三、HTTPDNS

既然我们面临这么严峻的问题，那么我们如何优化 DNS 呢？答案就是 HTTPDNS。



大部分标准 DNS 都是基于 UDP 与 DNS 服务器交互的，HTTPDNS 则是利用 HTTP 协议与 DNS 服务器交互，绕开了运营商的 Local DNS 服务，有效防止了域名劫持，提高域名解析效率，下图是 HTTPDNS 的原理。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/671b6a5e82ace7eb549bfe74bdeb8d66.jpg)



HTTP DNS 原理



百度 App HTTPDNS 端上的实现是基于百度 SYS 团队的 HTTPDNS 服务，下图介绍了 HTTPDNS 的服务端部署结构。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/0bcb91fd135c7d4af3170d9f5b5a2f80.jpg)



HTTP DNS 部署结构



HTTPDNS 服务是基于 BGP 接入的，BGP 英文 Border Gateway Protocol，即边界网关协议，是一种在自治系统之间动态的交换路由信息的路由协议，BGP 可以根据当前用户的运营商路由到百度服务点的对应集群上，对于第三方域名，服务点会通过百度部署在运营商的 CDN 节点向其他域名权威 DNS 发起查询，查询这个运营商下域名的最优 IP。



百度 App 独立实现了端的 HTTPDNS SDK，下图介绍了端 HTTPDNS 的整体架构。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/e5da1ed5eb476753955d5bfdd5401716.jpg)



端 HTTP DNS 的整体架构



### DNS 接口层：

DNS 接口层解决的问题是屏蔽底层的细节，对外提供简单整洁的 API，降低使用者的上手成本，提高开发效率。



### DNS 策略层：

DNS 策略层通过多种策略的组合，使 HTTPDNS 服务在性能，稳定性，可用性上均保持较高的水准，下面讲解下每个策略设计的初衷和具体实现。



### 1.容灾策略

这是一个非常关键的策略，主要解决 HTTPDNS 服务可用性的问题，实践证明，这个策略帮助百度 App 在异常情况下挽救回很多流量。



【1】当 HTTPDNS 服务不可用并且本地也没有缓存或者缓存失效的时候，会触发降级策略，降级成运营商的 localDNS 方案，虽然存在运营商事故或者劫持的风险，但保障了 DNS 服务的可用性。



【2】当 HTTPDNS 服务和 localDNS 服务双双不可用的情况下，会触发 backup 策略，使用端上的 backup IP。



什么是 backup IP？backup IP 是多组根据域名分类的 IP 列表，可云端动态更新，方便后续运维同学调整服务端的节点 IP，不是所有域名都有对应的 backup IP 列表，目前百度 App 只能保证核心域名的可用性。



既然是一组 IP，便有选取问题，backup IP 选取机制是怎样的呢？我们的中心思想就是要在端上利用最小的代价，并且考虑服务端的负载均衡，得到相对正确或者合理的选取结果。通过运营商和地理信息，可以选择一个相对较优的 IP，但获取地理信息需要很大耗时，外加频次很高，代价很大，所以我们选择了 RR 算法来代替上面的方法（RR 算法是 Round-Robin，轮询调度），这样客户端的代价降低到最小，服务端也实现了负载均衡。



### 2.安全策略

【1】HTTPDNS 解决的核心问题就是安全，标准的 DNS 查询大部分是基于 UDP 的，但也有基于 TCP 的，如果 UDP 被封禁，就需要使用 TCP。不管是 UDP 还是 TCP，安全性都是没有保障的，HTTPDNS 查询是基于标准的 HTTP 协议，为了保证安全我们会在 HTTP 上加一层 TLS（安全传输层协议），这便是 HTTPS。



【2】解决了传输层协议的安全性后，我们要解决下域名解析的问题，上面我们提到 HTTPDNS 服务是基于 BGP 接入的，在端上采用 VIP 方式请求 HTTPDNS 数据（VIP 即 Virtual IP，VIP 并没有与某设备存在必定的绑定关系，会跟随主备切换之类的情况发生而变换，VIP 提供的服务是对应到某一台或若干台服务器的），既然请求原始数据需要使用 IP 直连的方式，那么就摆脱了运营商 localDNS 的解析限制，这样即使运营商出现了故障或者被劫持，都不会影响百度 App 的可用性。



### 3.任务调度策略

HTTPDNS 服务提供了两类 HTTP 接口，用于请求最优域名结果。第一种是多域名接口，针对不同的产品线，下发产品线配置的域名，第二种是单域名接口，只返回你要查询的那个域名结果，这样的设计和标准的 DNS 查询基本是一样的，只不过是从 UDP 协议变成了 HTTP 协议。



【1】多域名接口会在 App 冷启动和网络切换的时候请求一次，目的是在 App 的网络环境初始化或者变化的时候预先获取域名结果，这样也会减少单域名接口的请求次数。



【2】单域名接口会在本地 cache 过期后，由用户的操作触发网络请求，进而做一次单域名请求，用户这次操作的 DNS 结果会降级成 localDNS 的结果，但在没有过期的情况下，下次会返回 HTTPDNS 的结果。



### 4.IP 选取策略

IP 选取策略解决的核心问题是最优 IP 的选取，避免因为接入点的选取错误造成的跨运营商耗时。HTTPDNS 服务会将最优 IP 按照顺序下发，客户端默认选取第一个，这里没有做客户端的连通性校验的原因，主要还是担心端上的性能问题，不过有容灾策略兜底，综合评估还是可以接受的。



### 5.缓存策略

大家对于 DNS 缓存并不陌生，它主要是为了提升访问效率，操作系统，网络库等都会做 DNS 缓存。



DNS 缓存中一个重要的概念就是 TTL（Time-To-Live），在 localDNS 中针对不同的域名，TTL 的时间是不一样的，在 HTTPDNS 中这个值由服务端动态下发，百度 App 目前所有的域名 TTL 的配置是 5 分钟，过期后如果没有新的 IP 将继续沿用老的 IP，当然也可以选择不沿用老的 IP，而降级成 localDNS 的 IP，那么这就取决于 localDNS 对于过期 IP 的处理。



### 6.命中率策略

如果 HTTPDNS 的命中率是 100%，在保证 HTTPDNS 服务稳定高效的前提下，我们就可以做到防劫持，提升精准调度的能力。



【1】为了提升 HTTPDNS 的命中率，我们选择使用多域名接口，在冷启动和网络切换的时候，批量拉取域名结果并缓存在本地，便于接下来的请求使用。



【2】为了再一次提升 HTTPDNS 的命中率，当用户操作触发网络请求，获取域名对应的 IP 时，会提前进行本地过期时间判断，时间是 60s，如果过期，会发起单域名的请求并缓存起来，这样会持续延长域名结果的过期时间。本地过期时间与上面提到的 TTL 是客户端和服务端的双重过期时间，目的是在异常情况下可以双重保证过期时间的准确性。



### 基础能力层：

基础能力层主要提供给 DNS 策略层所需要的基础能力，包括 IPv4/IPv6 协议栈探测的能力，数据传输的能力，缓存实现的能力，下面将讲解每种能力的具体实现



### 1.IPv4/IPv6 协议栈探测：

百度 App 的 IPv6 改造正在如火如荼的进行中，端上在 HTTPDNS 的 IP 选取上如何知道目前属于哪个协议栈成为关键性问题，并且这种判断要求性能极高，因为 IP 选取的频次实在是太高了。



我们选取的方案是 UDP Connect，那么何为 UDP Connect？大家都知道 TCP 是面向连接的，传输数据前客户端都要调用 connect 方法通过三次握手建立连接，UDP 是面向无连接的，无需建立连接便能收发数据，但是如果我们调用了 UDP 的 connect 方法会发生什么呢？当我们调用 UDP 的 connect 方法时，系统会检测其端口是否可用，地址是否正确，然后记录对端的 IP 地址和端口号，返回给调用者，所以 UDP Connect 不会像 TCP Connect 发起三次握手，发生网络真实损耗，UDP 客户端只有调用 send 或者 sendto 方法后才会真正发起真实网络损耗。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/da7fa15bf8ffa193db17357b51e1fb86.jpg)



UDP Connect 原理



有了 UDP Connect 的基础保障，我们在上层做了缓存机制，用来减少系统调用的损耗，时机上目前仅在冷启动和网络切换会触发探测，在同一种网络制式下探测一次基本可以确保当前网络是 IPv4 栈还是 IPv6 栈。



目前百度 App 客户端对于 IPv4/IPv6 双栈的策略是保守的，仅在 IPv6-only 的情况下使用 v6 的 IP，其余使用的都是 v4 的 IP，双栈下的方案后续需要优化，业内目前标准的做法是 happy eyeball 算法，什么叫 happy eyeball 呢？就是不会因为 IPv4 或 IPv6 的故障问题，导致用户的眼球一直在等待加载或者出错，这就是 happy eyeball 名字的由来。happy eyeball 有 v1 版本 RFC6555 和 v2 版本 RFC8305，前者是 Cisco 提出来的，后者是苹果提出来的。happy eyeball 解决的核心问题是，复杂环境下 v4 和 v6 IP 选取的问题，它是一套整体解决方案，对于域名查询的处理，地址的排序，连接的尝试等方面均做出了规定，感兴趣的同学可以查看参考资料里的【5】和【6】。



### 2.数据传输：

数据传输主要提供网络请求的能力和数据解析的能力。



【1】网络请求失败重试的机制，获取 HTTPDNS 结果的成功率会大大影响 HTTPDNS 的命中率，所以客户端会有一个三次重试的机制，保障成功率。



【2】数据解析异常的机制，如果获取的 HTTPDNS 的结果存在异常，将不会覆盖端上的缓存。



### 3.缓存实现：

缓存的实现基本可以分为磁盘缓存和内存缓存，对于 HTTPDNS 的缓存场景，我们是选其一还是都选择呢？百度 App 选择的是内存缓存，目的是防止我们自己的服务出现问题，运维同学在紧急情况下切换流量，如果做了磁盘缓存，会导致百度 App 在重启后也可能不可用，但这种问题会导致 APP 在冷启动期间，HTTPDNS 结果未返回前，还是存在故障或者劫持的风险，综合评估来看可以接受，如果出现这种极端情况，影响的是冷启动阶段的一些请求，但只要 HTTPDNS 结果返回后便会恢复正常。



## 四、HTTPDNS 的最佳实践

百度 App 目前客户端网络架构由于历史原因还未统一，不过我们正朝着这个目标努力，下面着重介绍下 HTTPDNS 在 Android 和 iOS 网络架构中的位置及实践。



### HTTP DNS 在 Android 网络架构的位置及实践

百度 App 的 Android 网络流量都在 okhttp 之上，上层进行了网络门面的封装，封装内部的实现细节和对外友好的 API，供各个业务和基础模块使用，在 okhttp 上我们扩展了 DNS 模块，使用 HTTPDNS 替换了原有的系统 DNS。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/e4642b4fc3cbf86dfdbc78d1c09c218c.jpg)



HTTP DNS 在 Android 网络架构的位置



### HTTP DNS 在 iOS 网络架构的位置及实践

百度 App 的 iOS 网络流量都在 cronet（chromium 的 net 模块）之上，上层我们使用 AOP 的方式将 cronet stack 注入进 URLSession 里，这样我们就可以直接使用 URLSession 的 API 进行网络的操作而且更易于系统维护，在上层封装了网络门面，供各个业务和基础模块使用，在 cronet 内部我们修改了 DNS 模块，除了原有的系统 DNS 逻辑外，还添加了 HTTPDNS 的逻辑。iOS 上还有一部分流量是在原生 URLSession 上，主要是有些第三方业务没有使用 cronet 但还想单独使用 HTTPDNS 的能力，所以就有了下面的 HTTPDNS 封装层，方法是在上层直接将域名替换成 IP，域名对于底层很多机制是至关重要的，比如 https 校验，cookie，重定向，SNI（Server Name Indication）等，所以将域名修改成了 IP 直连后，我们又处理了以上三种情况，保证请求的可用性。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/6d211901eef6bed47e57d374063dce45.jpg)



HTTP DNS 在 iOS 网络架构的位置



## 五、收益

DNS 优化的收益主要有两点，一是防止 DNS 的劫持（在出问题时显得尤为重要），降低网络时延（在调度不准确的情况下，会增大网络的时延，降低用户的体验），这两点收益需要结合业务来说，以百度 App Feed 业务为例，第一点上我们取得了比较大的效果，iOS 劫持率由 0.12%降低到 0.0002%，Android 劫持率由 0.25%降低到 0.05%，第二点的收益不明显，原因在于 Feed 业务主要目标群体在国内，百度在国内节点布局相对丰富，服务整体质量也较高，即使出现调度不准确的情况，差值也不会太大，但如果在国外情况可能会差很多。



## 六、结语

DNS 优化是个持续性的话题，上面介绍的百度 App 的一些经验和做法并不见得完美，但我们会持续深入的优化下去，为百度 App 的 DNS 能力保驾护航。最后感谢大家的辛苦阅读，希望对你有所帮助，后面会继续推出-百度 App 网络深度优化系列《二》连接优化，敬请期待。



## 七、个人心得

做为一个工程师，如何才能做好网络优化这件事情，是个值得我们交流探讨的话题，个人认为应该从以下五方面入手。



【1】基础知识要了解学习，要夯实，网络相关的内容很多，很杂，不易学习，啃过 IETF 发布的 RFC 的同学应该深有感触。



【2】学会将看不见的网络变成看得见的，很多自认为对于网络很了解的同学，动不动就背诵 tcp 协议原理，拥塞控制算法，滑动窗口大小等，但真正遇到线上问题，无从下手。对于客户端同学，我们在 PC 上要学会使用 tcpdump 和 Wireshark 等工具，适当使用 Fiddler 和 Charles 等工具，很多时候电脑和手机的网络环境不见得一致，所以要在手机上使用 iNetTools，Ping&DNS 或终端工具。学会使用工具后，要学着创造不同的网络环境，有很多工具能帮助你完成这点，比如苹果的 Network Link Conditioner，FaceBook 的 ATC（Augmented Traffic Control）等。具备以上两个场景后，你的第一条储备就发挥了作用，你要能看懂握手过程，传输过程，异常断开过程等。



【3】有了以上两点的准备，接下来需要一个会出现各种网络问题的平台，给你积累经验，让一个个高压下的线上问题锤炼你，折磨你。



【4】网络优化是需要数据支撑的，但数据的采集和分析是需要经验的，有些数据一眼看下去就是不靠谱的，有些数据怎么分析都是负向收益的，一般来说是有三重奏来对数据进行分析的，一，线下数据的采集和分析，得出正向收益，二，灰度数据的采集和分析，得出正向收益，三，线上数据的采集和分析，得出正向收益。



【5】数据的正向收益，不能完全证明提升了用户的体验，所以很多时候需要针对特定场景，特定 case 来分析和优化，就算是大家公认做的很好的微信，也不是在所有场景下都能保证体验上的最佳。



## 八、参考资料

- https://chromium.googlesource.com/chromium/src/+/HEAD/docs/android_build_instructions.md
- https://chromium.googlesource.com/chromium/src/+/HEAD/docs/ios/build_instructions.md
- https://github.com/Tencent/mars
- https://tools.ietf.org/html/rfc7858
- https://tools.ietf.org/html/rfc6555
- https://tools.ietf.org/html/rfc8305



## 作者简介

**蔡锐**，9 年移动客户端开发经验，在百度先后主导过订制 ROM 领域、多屏互动领域、Hybrid 跨平台领域等多个技术领域的开发，目前担任百度 App 的客户端资深工程师，参与基础技术的研究，专攻动态化和网络优化方向。







# 百度 App 网络深度优化系列（二）：连接优化



## 一、前言

[在系列(一)](https://www.infoq.cn/article/3QZ0o9Nmv*O0LoEPVRkN)里大家了解到网络优化一般会**首选优化 DNS**，而接下来的 HTTP 协议成为优化的重点，一般优化者会选择协议切换，合并请求，精简数据包大小等手段来对 HTTP 协议进行优化，严谨的说这都不属于网络优化的范畴。



**HTTP 协议的基础是连接，所以我们的系列《二》连接优化应运而生**，希望对大家在网络方向的学习和实践有所帮助。



## 二、背景

连接优化需要解决两个核心问题



1. **连接建立耗时较长，导致请求的总时长变长，进而影响用户体验**。
2. **在多变的网络环境下，连接建立的过程可能会失败，导致成功率下降，进而影响用户体验**。



百度 App 承载着亿级流量，对于每一个请求都需要追求耗时短，成功率高的体验。从协议角度出发，如何才能做到这一点呢？首先我们来看下建立连接耗时的原理。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/676de998108ed28b4735a61eb5a05186.png)



建立连接耗时的原理



从上图我们能清晰的看出



1. DNS Query 需要 1 个 RTT（Round-Trip Time，即往返时间），百度 App 都是基于 HTTPDNS 服务的，所以大部分会命中缓存，如果降级走了系统 DNS，也会命中缓存，命中不了的由于是基于 UDP 协议，所以在连接耗时上没有太大的影响，线上的数据也能说明这点。
2. TCP 要经历 SYN，SYN/ACK，ACK 三次握手的 1.5 个 RTT，不过 ACK 和 ClientHello 合并了，所以就是 1 个 RTT。
3. TLS（Transport Layer Security，即传输层安全性协议）需要经过握手和密钥交换 2 个 RTT。



**综上所述，DNS，TLS，TCP 握手阶段用了 4 个 RTT 才到了 ApplicationData 阶段，也就是数据开始传输阶段**。



通过上面的分析可以总结出，如果我们能尽量的将 TLS 和 TCP 的 RTT 减少，将会大大降低连接耗时的时间。



## 三、连接优化我们都能做什么

百度 App 的优化目标分为两类，**一类是 TLS 的连接优化，一类是 TCP 的连接优化**。



### **TLS 的连接优化**

TLS 的连接优化，需要服务端和客户端都需要支持，共同完成优化手段，包括 Session Resumption 和 False Start。



#### Session Resumption

Session Resumption 中文意思是会话复用，下图讲解了 Session Resumption 的协议原理。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/001ed85a2c6523ac2436a0c80eeb5226.png)



Session Resumption 的协议原理



通过上图可以看出 TLS 密钥协商交换的过程没有了，但具体是如何实现的呢？包含两种方式，**一种是 Sesssion Identifier，一种是 Session Ticket**。



#### 1）Session Identifier

Session Identifier 中文为会话标识符，**更像我们熟知的 session 的概念**。是 TLS 握手中生成的 Session ID。服务端会将 Session ID 保存起来，客户端也会存储 Session ID，在后续的 ClientHello 中带上它，服务端如果能找到匹配的信息，就可以完成一次快速握手。



#### 2）Session Ticket

Session Identifier 存在一些弊端，比如客户端多次请求如果没有落在同一台机器上就无法找到匹配的信息，但 Session Ticket 可以。**Session Ticket 更像我们熟知的 cookie 的概念**，Session Ticket 用只有服务端知道的安全密钥加密过的会话信息，保存在客户端上。客户端在 ClientHello 时带上了 Session Ticket，服务器如果能成功解密就可以完成快速握手。



不管是 Session Identifier 还是 Session Ticket 都存在时效性问题，不是永久生效，对于这两种方式大家可以查看参考资料【4】。**百度 App 的网络协议层对这两种方式都是支持的**，省去了 TLS 握手过程中证书下载，密钥协商交换的环节，节省了 1 个 RTT 的时间。



#### False Start

False Start 的中文意思是抢跑，下图讲解了 False Start 的协议原理。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/328accbd422fdb8078d16ed0e6bc5c1c.png)



False Start 的协议原理



上图很清晰的说明在 TLS 第一步握手成功后，客户端在发送 Change Cipher Spec Finished 的同时开始数据传输，服务端在 TLS 握手完成时直接返回应用数据。**应用数据的发送实际上并未等到握手全部完成，所以称之为抢跑**。



从结果看省去了 1 个 RTT 的时间。False Start 有两个前提条件，一是要通过应用层协议协商 ALPN（Application Layer Protocol Negotiation）握手，二是要支持前向安全的加密算法。False Start 在未完成握手的情况下就发送了数据，前向安全可以提高安全性，具体协议实现，大家可以查看参考资料【3】。百度 App 的网络协议层对 False Start 是支持的。



这里说句题外话，其实 TCP 层有个类似的连接优化手段叫 Fast Open，感兴趣的同学，可以查看参考资料【5】。



#### Session Resumption 和 False Start 的区别

两者对于 TLS 来说都是节省一个 RTT，Session Resumption 在第一次握手时还是需要 2 个 RTT，在第二次握手时才能复用减少到 1 个 RTT。False Start 是端上的行为，故每次都会减少到 1 个 RTT。



### **TCP 的连接优化**

TCP 的连接优化，我们先从连接池说起，首先让我们来认识下连接池都有哪些类型。



#### 1. 连接池

![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/251cf7541a5a070d0d262451111172a5.png)



连接池的类型



上图展示了连接池的不同类型，都是大家耳熟能详的协议连接池，有低级连接池，包含 TCP 连接池（管理 HTTP 请求的连接）和 WebSocket 连接池（管理 WebSocket 连接）。



有高级连接池，包括 HTTP 代理连接池（管理 HTTP 代理请求的连接），SpdySession 连接池（管理 SPDY 和 HTTP/2 请求的连接），SOCKS 连接池（管理 SOCKS 和 SOCKS5 代理的连接），SSL 连接池（管理 HTTPS 请求的连接）。



**不同类型的连接池以组合的形式互相复用能力。**



1）SSL 连接池管理的是 SSLSocket，但 SSLSocket 又依赖于 TCP 连接池提供的 TCPSocket。



2）HTTP 代理连接池如果走 HTTP 协议，那么就需要 TCP 连接池提供 TCPSocket，如果走 HTTPS 协议，那么就需要 SSL 连接池提供 SSLSocket。



3）SpdySession 连接池依赖 SSL 连接池提供 SSLSocket，这里需要说明下，虽然 HTTP/2 协议没有强制绑定 HTTPS，但是在实际开发中确实都是绑定 HTTPS，百度 App 使用 ALPN 来协商 HTTP/2。



4）SOCKS 连接池管理的 SOCKSSocket 和 SOCKS5Socket 都需要依赖 TCP 连接池提供的 TCPSocket，虽然 SOCKS5 支持 UDP，但 cronet 网络库暂时没有实现。



5）WebSocket 连接池依赖 TCP 连接池提供的 TCPSocket，声明下这里没有说明 WSS（Web Socket Secure）的情况。



TCP 连接优化是一个比较复杂的内容，**百度 App 做了针对性场景优化，包括预连接，连接重建，备用连接，复合连接**。



#### 2.  预连接

![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/827f5f6ba3ace3bcab455e6164561e1e.png)



预连接和连接重建



预连接，预先创建好的连接。**它解决的场景是在 App 使用阶段可以无耗时的获取连接**。下面用四个问答来解释预连接。



**问题一：预连接是否能解决所有网络请求的提前连接建立？**



答：答案是否定的，预连接需要业务方进行核心业务的评估，针对核心的域名进行预连接的建立。



**问题二：预连接既然针对的是特定的域名，那么是如何配置的呢？**



答：采用域名+连接数的方式进行配置，比如[https://a.baidu.com](https://a.baidu.com/)|2，表示给 a.baidu.com 这个域名配置两条预连接，这里要说明下，在 HTTP/1.x 协议下，网络库的实现都会对于单域名有最大连接数的限制，不同网络库的个数限制不一样，有 5 个也有 6 个，但对于 HTTP/2 协议，这个连接数就只能是 1 个。



**问题三：预连接是如何建立的？**



答：在网络库初始化的时候，会根据使用者的配置延迟 5s 进行预连接的建立，主要是考虑网络库在冷启动下对于启动性能的影响，为了保证网络库的整体性能，预连接的总个数限制在 20 个。



**问题四：预连接是如何保持的？**



答：在网络库初始化的时候，除了进行预连接的建立，还会创建一个预连接的定时器，这个定时器会每隔 31s，这个值的设定取决于 BFE（Baidu Front End，是七层流量的统一接入系统）和 BGW（Baidu Gate Way，百度自主研发的四层负载均衡平台）对超时的最小值设定，根据使用者的配置重新建立连接。



#### 3.  连接重建

连接重建，将连接重新建立。**它解决的场景是 App 网络状态发生变化，IP 地址变化，导致连接不可用**。下面用三个问答来解释连接重建。



**问题一：连接重建是否针对连接池里的所有连接？**



答：答案是肯定的。



**问题二：连接重建的过程是什么样的？**



答：在网络状态变化的时候，第一步会清除掉连接池里的 idle socket，何为 idle socket？即空闲 socket，对于从未使用过的空闲 socket 超过 60 秒清除，对于使用过的空闲 socket 超过 90 秒清除。第二步重建连接需要等待 200ms，目的是等待 DNS 先重建完成。



**问题三：连接重建对于性能有影响吗？**



答：出于性能考虑，连接重建的连接个数限制是 100 个。



#### 4.  备用连接

![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/24d1ac6438e2657c6cabf5ab4a861897.png)



备用连接和复合连接



备用连接，预备的连接。**它解决的场景是正常发送一个请求当 group 内无连接可用的时候**（何为 group？group 是管理 socket 的最小单元，内部包含活跃 socket，空闲 socket，连接任务，等待请求）。下面用三个问答来解释备用连接。



**问题一：备用连接是否针对所有请求？**



答：答案是肯定的。



**问题二：备用连接的过程是什么样的？**



答：当有请求来临时，连接池内无连接可用，会启动一个定时器开启备用连接，定时器的间隔时间是 250ms，与主连接进行竞争，如果主连接因为网络抖动或者网络状态不好，导致连接失败，那么备用连接就直接发送请求。如果主连接成功，那么备用连接就被取消掉。



**问题三：备用连接的目的是什么？**



答：在连接池无连接的情况下，务必是要创建连接的，在主连接之外加一个备用连接，会大大提升创建连接的成功率，从而提升用户体验。



#### 5.  复合连接：

复合连接，即多条连接。**它解决的场景是为了多个 IP 地址的连接选取问题**。下面用三个问答来解释复合连接。



**问题一：复合连接是否针对所有请求？**



答：答案是肯定的。复合连接可以全局开关，百度 App 现阶段暂时没有开启复合连接。



**问题二：复合连接的过程是什么样的？**



答：众所周知域名 DNS 查询一般情况下会返回多个 IP，我们以域名查询返回两个 IP 为例



1）如果结果中存在 IPv6 的地址，那么会优先选用 IPv6 的地址，这个规则 follow HappyEyeBall 机制（可参考系列一对于 HappyEyeBall 的介绍）。



2） 接下来这两个 IP 会按照顺序尝试建立连接，如果第一个 IP 返回失败，将立即开始连接第二个 IP。



3）如果第一个 IP 率先成功返回，那么第二个 IP 将被加入连接尝试列表并停止所有尝试连接。



4）如果第一个 IP 失败，会立刻开始第二个 IP 的连接。



5）如果第一个 IP 处于 pending 状态，那么会启动一个定时器，默认延迟 2s 会发起第二个 IP 的连接，如果是多个 IP 将会递归连接，需要特别说明下，不同的网络制式延迟时间会不一样，这样体验也会更好。



**问题三：复合连接的目的是什么？**



答：复合连接的好处是提供最优的 IP 选取机制，但也会带来服务端的高负载，所以使用的时候需要进行综合评估。



## 四、连接优化的最佳实践

百度 App 目前客户端网络架构由于历史原因还未统一，不过我们正朝着这个目标努力。



**我们的中心思想是以系统网络库的 API 调用接口为中心，上层建立网络门面，供外部便捷调用，底层通过系统机制以 AOP 的方式将 cronet（chromium 的 net 模块）注入进系统网路库，达到双端网络架构统一，能力复用**。



下面着重介绍下连接优化在 Android 和 iOS 网络架构中的位置及实践。



1. 连接优化在 Android 网络架构的位置及实践



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/4bc68fcd4709c32e6af46cc375d641d6.png)



连接优化在 Android 网络架构的位置



百度 App 的 Android 网络流量目前都在 okhttp 之上，上层进行了网络门面的封装，封装内部的实现细节和对外友好的 API，目前我们正在进行重构，默认采用 Android 标准的网络接口 HttpURLConnection，它的底层由系统提供的 okhttp 的实现。



订制方面利用 URL Stream Protocol 机制将 HttpURLConnection 底层网络协议栈接管为 cronet，供各个业务和基础模块使用，连接优化的所有内容在 cronet 网络库内部实现。



### 2.  连接优化在 iOS 网络架构的位置及实践

![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/4bd77231ebd9528c856fd059cea89f6d.png)



连接优化在 iOS 网络架构的位置



百度 App 的 iOS 网络流量目前都在 cronet 之上，上层我们使用 iOS 的 URL Loading System 机制将 cronet stack 注入进 URLSession 里，这样我们就可以直接使用 URLSession 的 API 进行网络的操作而且更易于系统维护，在上层封装了网络门面，供各个业务和基础模块使用。



**在 cronet 内部实现了预连接（主要针对百度 App 的几个核心域名进行预连和保活），连接重建（针对所有请求），备用连接（针对所有请求），复合连接（iOS 上暂时没有开启），Session Resumption（针对所有请求），False Start（针对所有请求）**。



## 五、收益

连接优化的收益主要体现在网络时延和网络成功率上，这两点收益需要结合业务来说，以百度 App Feed 刷新这个典型业务场景为例。



Feed 刷新文本请求网络时延**降低 16%**，Feed 刷新图片请求网络时延**降低 12%**，可谓收益相当明显。



成功率方面，Feed 刷新文本请求成功率**提升 0.29%**，Feed 刷新图片请求成功率**提升 0.23%**，也是非常不错的收益。



## 六、结语

连接优化是个持续性的话题，没有最优只有更优。上面介绍的百度 App 的一些经验和做法并不见得完美，但我们会继续深入的优化下去，持续提升百度 App 的网络性能。



以上优化由百度 App 团队，内核团队，OP 团队共建完成。最后感谢大家的辛苦阅读，希望对你有所帮助，后面会继续推出-百度 App 网络深度优化系列《三》弱网优化，敬请期待。



## 七、参考资料

1. https://chromium.googlesource.com/chromium/src/+/HEAD/docs/android_build_instructions.md
2. https://chromium.googlesource.com/chromium/src/+/HEAD/docs/ios/build_instructions.md
3. https://tools.ietf.org/html/rfc7918 False Start
4. https://tools.ietf.org/html/rfc5077 Session Resumption
5. https://tools.ietf.org/html/rfc7413 TCP Fast Open



## 作者简介

**蔡锐**，9 年移动客户端开发经验，在百度先后主导过订制 ROM 领域、多屏互动领域、Hybrid 跨平台领域等多个技术领域的开发，目前担任百度 App 的客户端资深工程师，参与基础技术的研究，专攻动态化和网络优化方向。









# 百度 App 网络深度优化系列（三）：弱网优化



## 前言

网络优化解决的核心问题有三个，**第一是安全问题**，我们在[系列《一》DNS优化](https://www.infoq.cn/article/3QZ0o9Nmv*O0LoEPVRkN)进行了详细的讲解。**第二是速度问题**，我们[系列《二》连接优化](https://www.infoq.cn/article/CDaih849Ao4rS_pctQ2T)也做了详细的介绍。**第三是弱网问题**，它是网络优化中最为复杂且需要反复验证和分析的问题，我们的系列《三》弱网优化就是要深入探讨这个问题。



## 背景

弱网优化需要解决的核心问题有两点:



- **移动网络环境如此复杂，我们如何确定当下就是弱网环境**。
- **确定为弱网环境下，我们如何提升弱网下的成功率，降低弱网下的时延，进而提升用户的网络体验**。



百度 App 承载着亿级流量，**弱网比例 0.95%**，可谓不小，这个比例是如何得来的呢？还是要从什么是判断弱网指标说起。



## 判断弱网的指标

首先我们来探讨下都有哪些指标会影响到网络的质量，包括 httprtt，tcprtt，throughput，signal strength，bandwidth-delay product。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/c6131a10195f1f60e51b20dcd7a13088.png)



影响网络质量的指标



#### 1.httprtt

httprtt（http Round-Trip Time）又名 TTFB（Time to first byte），**指从客户端请求的第一个字节开始发送到接收到 http header 的第一个字节的时间差**。httprtt 的时间如果过长，一方面是客户端本身接入网络质量的问题，另一方面是服务的延时比较大。



#### 2.tcprtt

tcprtt（tcp Round-Trip Time）**指客户端 tcp 信道第一个字节发送到接收第一个字节的时间差**。因为 HTTP 协议底层是基于 TCP 的，所以在复用同一条 tcp 连接的前提下，httprtt 的时间是包含 tcprtt 的时间的。大部分情况下 httprtt 已经可以说明问题的原因。



#### 3.throughput

throughput，中文名字吞吐量，**它是用来衡量单位时间内成功传送数据的数量，是可以比较客观的衡量网络质量的指标**。吞吐量 =（获 bits 结束大小 - 获 bits 开始大小）/（获 bits 结束时间 - 获 bits 开始时间），这里有个细节需要注意，posix socket 的 read 函数返回值是 bytes，所以要乘以 8 得到 bits。通常在 httprtt 比较小的情况下，网络依然很慢，这个时候就可以使用吞吐量来确定网络的质量。



#### 4.signal strength

signal strength，**这里指的是无线信号强度**，在 Android 上可以通过 PhoneStateListener 的 onSignalStrengthsChanged 方法获取到信号强弱，但要注意只能在 Android M 以上的版本才生效。iOS 上暂时没有靠谱的实现。



#### 5.bandwidth-delay product

bandwidth-delay product，中文名**带宽时延乘积**，**指的是一个数据链路的能力（throughput）与来回通信延迟（rtt）的乘积**。带宽时延乘积的结果是比特不是位，这个比特值反应出当前网络管道的最大容量。TCP 中有一个窗口大小的概念，会限制发送和接收数据的大小，所以 TCP 窗口大小的调节是直接受带宽时延乘积的影响，根据带宽时延乘积的值去设置套接字的 setsockopt 方法，设置的 option 是 SO_RCVBUF（接收缓冲区大小）和 SO_SNDBUF（发送缓冲区大小）。



通过上面的内容，我们对影响网络质量的指标有了一定了解，**对于不同的产品，影响网络质量的指标可以理解成一样的，但对于每个指标的阈值肯定是不一样的**，因为这包含着业务场景，比如抖音是视频类网络传输，微信是长连接数据传输，百度是文本图片类数据传输。还包括服务端配备，不同产品线的服务集群能力肯定不一样，比如返回客户端的服务端耗时肯定不一样。所以针对不同的产品弱网指标是基本一致的，但是指标的取值肯定是不一样的。



## 如何建立弱网标准

建立弱网标准是一个循序渐进的过程，在一穷二白的时候我们应该如何建立这个标准呢？答案分为三个阶段。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/ef7e3bb9dd7665462fcc5a122162d19e.png)



建立弱网标准的步骤：



1. **第一阶段，线下进行测试。**获取一些符合我们预期的阈值，这个时候我们需要借助一些网络测试工具，比如苹果的 Network Link Conditioner，Facebook 的 ATC（Augmented Traffic Control），来获取到线下不同网络情况的阈值，一般我们会测试 App 冷启动的场景，网络切换的场景，DNS 故障场景，弱网场景（一般都是配置上下行的带宽，丢包率，延迟，DNS 延迟参数，或者更为简单的是使用工具默认的一些弱网配置）。
2. **第二阶段，线上进行验证**。通过线下充分测试获取到的阈值，在线上可以获取到弱网的比例，在这里百度 App 是针对特定场景的，比如 Feed 刷新，搜索落地页打开等，就算是在移动时代被大家公认的网络体验好的微信，也只是在信令传输（收发消息）上做到极致优化，所以针对场景搜集弱网数据很重要。
3. **第三阶段，线上的反复试验**。想做到理想的弱网效果，少不了线上反复的阈值调整，通过调整阈值比较针对场景的网络请求的成功率、耗时、连接复用率等指标，使我们获得趋向于针对场景的合理阈值。



聊了这么多，那么弱网的探测如何实现呢？



## 网络探测的整体架构和实现

网络探测是弱网检测的基础，是否能即时，正确的检测出网络质量，是我们首先要解决的问题。我们把网络探测划分为两部分，**主动网络探测**和**被动网络采集**。



### 1.主动网络探测

所谓主动探测，**就是在触发了某些条件后，主动的进行网络探测，并按照一定的条件检查出是否是弱网状态**。百度 App 自研了主动探测组件，如下图所示。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/bc4897b934838c6a776ae2ace50750bb.png)



主动网络探测



#### 策略层

探测策略层通过多种策略的组合，使主动探测的即时性和准确性得以大大提高，我们结合上面的策略层图来解释下检测维度的意义。



我们分别在网络请求成功和失败的时候触发了弱网检测的逻辑。主要分为如下三种逻辑。



1）成功时，如何判断进入弱网状态？检查 weakhttprtt 的阈值，这个值取决于业务的设置（**一般这个值会针对特殊场景的请求取 95 分位或者更大分位的值**），大于这个值就会进入弱网检测，为了防止频繁触发探测加了时间间隔维度，目前定义的是 10 分钟。从线下模拟测试来看，只要大于这个阈值，检测结果必然是弱网状态。



2）成功时，如何判断退出弱网状态？检查 goodhttprtt 的阈值，这个值取决于业务的设置（**一般这个值会取整体网络的 95 分位或者更大分位的值**），小于这个值证明要切换回正常网络状态，为了防止频繁触发探测加了时间间隔维度，目前定义的是 30 秒。从线下模拟测试来看，只要小于这个阈值，检测结果必然是正常状态。如果大于或者等于这个阈值，也不能证明一定不是正常网络，所以也需要发起网络探测，但是由于这是在成功回调里，频次会很高，所以我们加上时间间隔的限制 30 秒，还加入了次数的限制，连续成功次数 %次数阈值（4 次）等于 0。但这看起来还是频次有点高，所以我们引入了阶梯递增机制，随着次数的增长，成 60 秒几何倍数增长。



3）失败时，如何判断进入弱网状态？首先会判断连续失败次数，连续失败次数/次数阈值（2 次）等于 1 并且连续失败次数 %次数阈值（2 次）等于 0，**相比成功，失败的次数检查较为苛刻，主要还是考虑多次触发网络检测损耗性能**。



**进入弱网状态后，就会触发基础能力层的 ping 和 dns query 的探测。**



#### 基础能力层

探测基础能力层，主要提供弱网检测的手段，**一是 dns query，一是 ping**，百度 App 使用 C++实现了这两个能力。为什么要选用这两种手段呢？我们在系列二中介绍过，一个网络请求，分为 DNS-》TLS-》TCP-》数据传输 四个阶段。想判定网络连通性主要在 DNS 和 TCP 阶段，所以 dns query 和 ping 就是用来检测这两个阶段的连通性手段。dns query 向百度核心域名[mbd.baidu.com](http://mbd.baidu.com/)发起 dns 查询，查询的 DNS 服务器为系统配置的 DNS 服务器（iOS 通过 res_ninit 函数构建一个__res_state 的结构体，Android 通过 systemproperty 获取 net.dns1 和 net.dns2 的值，便可获取系统配置的 DNS 服务器），DNS 查询的超时时间为 3s。ping 的目标地址为百度核心域名[mbd.baidu.com](http://mbd.baidu.com/)，ping 的次数为两次，每次超时时间是默认的 1s。



**判断出弱网状态后，会将结果提供给接口层。**



#### 接口层

接口层主要提供主动探测出来的网络状态，**目前包括 GOOD，BAD，UNKNOWN，OFFLINE**。



1）GOOD：dns 查询成功并且 ping 也成功，即标记为 GOOD 状态。



2）BAD：ping 失败一次标记为 BAD 状态。



3）UNKNOWN：初始状态或者识别不出来状态为 UNKNOWN 状态。



4）OFFLINE：dns server 错误（没有获取到要发送的 DNS server 地址），网关错误（读取/proc/net/route 文件内容失败），发送 dns 错误（发送 dns 数据出错），ping 读写错误（ping 的过程中读写错误），接收 dns 错误（接收 dns 数据出错），ping 地址错误（ping 地址是空），dns 未知域名错误（dns 没有查询到域名错误），初始化 icmp 错误（初始化 icmp 失败），dns udp 错误（创建 UDP socket 失败），即标记为 OFFLINE 状态。



### 2.被动网络采集

所谓被动采集，**就是每一次网络请求的所有细节都进行记录，并按照一定的条件将原始信息进行上报，上层再根据条件判断是否是弱网状态**。百度 App 基于 cronet 的 NQE（Network Quality Estimator）进行了二次订制开发。



首先我们讲解下需要采集的数据，包括 tcprtt、httprtt、throughput 三个维度，如下图所示。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/f6e6d8536c316ad6bef3eb03dd4f0a71.png)



被动采集数据



1）tcprtt，基于 posix 和 windows 的 socket 编程接口来获取 tcprtt。获取时机在连接完成，读完成和写完成。



2）httprtt，基于 HTTP 协议栈实现，通过计算接收 response 数据开始和开始发送的时间差，来获取 httprtt。获取时机在读首包完成时。



3）throughput，通过上面的计算公式需要获取 bytes 和时间，基于 posix 和 windows 的 socket 编程接口来获取 bytes。获取时机在读完成时记录接收的 bytes，在写完成时记录发送的 bytes。时间的获取在吞吐量管理模块里完成，下面会讲到。获取时机在请求完成和请求销毁时。



如下为被动网络采集的整体架构图。



![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/2640a8001b14140eea2bdf1d84330cbf.png)



被动网络采集



#### 能力层

**能力层内容上面我们已经讲过，主要采集 tcprtt、httprtt、throughput 三个维度的数据**。



#### 策略层

**被动采集策略层通过多种策略的组合，降低各种采集数据的上报时机，降低性能的影响**。



1）套接字管理模块，首先负责获取 tcprtt 的值，如何获取 tcprtt 呢？通过 getsockopt 函数获取 tcp_info 结构体里的 tcpi_rtt 值。其次由于 tcprtt 的上报频次比较频繁，所以做了 1 秒的时间间隔上报限制。



2）吞吐量管理模块，负责吞吐量的计算，上面介绍了计算公式，从网络活动监控器模块获取 bytes，但吞吐量的计算单位是 bits（位），所以将 bytes 乘以 8。只有 GET 请求会被列入统计计算，并且至少要累计 5 个请求后才能开始统计计算。排除精准度的干扰，比如 localhost，私有子网上的主机，特定用途子网主机，可参考 RFC1918。



3）网络质量管理模块，从套接字管理模块获取 tcprtt，从吞吐量管理模块获取吞吐量，并且在 HTTP 协议栈读首包完成时获取 httprtt。获取到这三个值后，需要经过一些策略限制上报的频次，10 秒间隔的限制；网络类型不能是 UNKNOWN（1.3 的第三部分会详细讲解）；网络不能频繁切换；rtt 和吞吐量总大小各 300 个。



#### 接口层

**接口层主要提供被动采集出来的网络状态，目前包括 GOOD，BAD，UNKNOWN，OFFLINE**。



1）GOOD：3G 和广义的 4G，任一条件满足标记为 GOOD 状态。通过阈值标记 3G 和广义的 4G，httprtt 大于等于 273ms，tcprtt 大于等于 204ms，即标记为 3G 状态。小于这两个值被标记为广义的 4G，所谓广义的 4G 包含 4G、WiFi、以及质量较好的各种接入网络。



2）BAD：慢 2G，2G 和 httprtt 大于 1.31 秒，任一条件满足标记为 BAD 状态。通过阈值标记慢 2G 和 2G，httprtt 大于等于 2.01 秒，tcprtt 大于等于 1.87 秒，标记为慢 2G。httprtt 大于等于 1.42 秒，tcprtt 大于等于 1.28 秒，标记为 2G。httprtt 大于 1.31 秒，为百度 App 的 Feed 刷新业务阈值。



注：上面涉及的时间值为 nqe 内部的机制，具有普适性。



3）UNKNOWN：非法的 httprtt，tcprtt，吞吐量，任一条件满足标记为 UNKNOWN 状态。何为非法？值为-1 为非法，那什么条件被标记为-1 呢？首先初始化时会被标记为-1，其次在从来没有获取到过 httprtt，tcprtt，throughput 的值时，会使用本地默认的值做为判断标准，这是一种容错处理。



4）OFFLINE：依赖平台能力进行判断，Android 平台依赖 ConnectivityManager 获取 NetworkInfo，通过 NetworkInfo 的 isConnected 获取是否连接，如果未连接则判断为 OFFLINE 状态，如果 NetworkInfo 为空则判断为 OFFLINE 状态。



## 弱网状态下百度 App 如何改善用户体验

![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/b663831ae80851b605280936eeabb74e.png)



百度 App 在弱网下的手段



### QUIC 在百度 App 弱网下的最佳实践

QUIC（Quick UDP Internet Connections）是新一代的互联网传输协议，最早源于 Google，它的详尽内容可参考资料【3】，本章我们不做 QUIC 的科普介绍。



百度 App 的普通网络请求在弱网状态下会切换到 QUIC，本章重点讲解下百度 App 针对弱网下开启 QUIC 后遇到的问题，**一是开启 QUIC 一旦遇到问题是否可以回滚？二是在弱网下如何能让流量尽可能的走 QUIC？针对这两个问题，我们的解决方案是 QUIC 升降级原理和 QUIC 预连接**。



#### 1.1QUIC 升降级原理

![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/21337ad1d48bf4e4a8d591b1e29dcd0f.png)



QUIC 升降级原理



如上图所示，QUIC 的升降级依赖于 HTTP Alternative Services，HTTP Alternative Services 是与 HTTP 有关的一个协议，它不是为 QUIC 专门设计的，在 HTTP 协议上主要负责新服务的替换，对于 HTTP1.1 协议，它是通过 HTTP 响应头传输回来的，所以只能在第二次请求时生效，如下面格式。



Alt-Svc: quic=“[alt.example.com](http://alt.example.com/):443”, quic=":443"; ma=2592000



如上信息表明切换到 quic 协议，指定了域名服务和端口，并且指定了生效时间，以秒为单位。



Alt-Svc: clear



如上信息表明将 alter 配置清空



在网络库内部有一个 alter 连接和原连接的竞争机制，如果 alter 信息已经存在，优先发送 alter 连接，而原连接会延迟发送，延迟时间默认 300ms，谁先成功就使用哪个连接，如果 alter 连接在 QUIC 握手时失败，会记录这个 alter 信息的失败次数，并根据失败的次数，计算出一个过期时间，这个过期时间会随失败次数指数增加，最长为 2 天。当过期时间到期后，会清除这个 alter 信息，当这个 alter 连接在 QUIC 握手成功后，会清除这个 alter 信息。



#### 1.2QUIC 预连接

所谓 QUIC 的预连接，就是在进入弱网状态前提前建立 QUIC 连接。大家都知道 QUIC 引以为傲的 0RTT，但第一次建立连接的时候是需要 1RTT 的，客户端首先会向服务器发送一个 client hello 消息，服务器会回复一个 server reject 消息，这个消息中包括了 server config，有了 server config 后客户端就可以直接计算出密钥，完成 0RTT，详尽内容可参考资料【4】。



通过上面的原理，客户端拉取 server config 的成功概率会直接影响 QUIC 在弱网下的流量，所以我们在 App 启动的过程中会做一次 QUIC 预连接，将 server config 拉取下来，这样等进入弱网后 alter 连接会大概率的竞争过原连接，进而走 QUIC 协议。



### 2.复合连接在百度 App 弱网下的最佳实践

复合连接的具体原理可以查看《百度 App 网络深度优化系列《二》连接优化》里的具体介绍，百度 App 目前在弱网下只是针对图片网络请求开启了复合连接，因为图片请求不管是 HTTPDNS 结果还是 localDNS 的结果都是多个 IP，这是满足复合连接的前提。在弱网下多 IP 的尝试会比单 IP 的结果好些，另外弱网的比例相对较小，复合连接对于服务器的负载也会小些。



## 百度 App 网络整体架构

![img](%E7%99%BE%E5%BA%A6APP%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96.assets/80b87772a58e7a7da4662bdd7004ec7b.png)



百度 App 网络整体架构



百度 App 网络整体架构，**以网络门面为中间层，隔离上层的最佳实践和底层的基础网络库**。



#### 最佳实践

客户端网络库的一部分工作量是在如何让最佳实践做的更好，在音视频上，不管是 iOS 的 AVPlayer，还是双端的 ijkPlayer，都是使用 HTTPDNS 组件接管 DNS 模块，没有全部接管网络模块。ReactNative 的网络模块 RCTNetworking，图片库 Android 的 Fresco 和 iOS 的 SDWebImage，WebView 组件 Android 的 Chromium 和 iOS 的 WKWebView，以及百度 App 的自有业务，都是通过网络门面的接口层直接接管。而对于第三方业务考虑到与宿主耦合的关系，直接使用 Android 的 HttpURLConnection 和 iOS 的 URLSession 系统标准的接口。



#### 网络门面

网络门面主要包括，拦截器模块（提供给业务订制网络门面的机制）、并发队列模块（提供高中低以及非常高的网络请求优先级）、网络探测组件（弱网主动探测能力）、网络诊断模块（包括 https，ping，dns 的校验）、HTTPDNS 组件（《百度 App 网络深度优化系列《一》DNS 优化》里详细讲解）、网络监控模块（客户端的打点机制，服务端的例行和突发监控）、HttpURLConnection 封装层、URLSession 封装层。



#### 基础网络库

基础网络库包含两部分，一部分是基于 cronet 二次订制的统一网络库，一部分是 WebSocket 基础库（Android 的 JavaWebSocket，iOS 的 SocketRocket）。统一网络库内部包含连接优化的内容（在《百度 App 网络深度优化系列《二》连接优化》里详细讲解），弱网优化的内容（上面提到的被动采集）。通过 AOP 的方式将底层协议栈注入进 HttpURLConnection（利用 URLStreamHandlerFactory）和 URLSession（利用 URLSessionConfiguration 的 protocolClasses 属性），两者都是系统提供的 URL Loading 机制。



## 收益

**弱网优化的收益我们主要从上面讲到的进入弱网状态后的手段来看，包括开启 QUIC，QUIC 预连接，开启复合连接**。



1）弱网下开启 QUIC 后，网络连接成功率提升 0.01%，平均耗时降低 23.5%。



2）弱网下开启 QUIC 预连接后，QUIC 协议的 pv 从 37 万涨到 90 万。



3）弱网下开启复合连接后，bad 状态下耗时降低 2.5%，offline 状态下耗时降低 7.7%。



## 结语

系列一到系列三的内容到今天全部完成，希望能对大家的工作和学习有所帮助，感谢大家的持续关注和鼓励。**生命不息，优化不止，做技术我们是认真的**。



#### 作者介绍

蔡锐，9 年移动端开发经验，在百度先后主导过订制 ROM 领域、多屏互动领域、Hybrid 跨平台领域等多个技术领域的开发，目前担任百度 App 的客户端资深工程师，参与基础技术的研究，专攻动态化、性能和网络优化方向。



#### 参考资料

- https://chromium.googlesource.com/chromium/src/+/HEAD/docs/android_build_instructions.md
- https://chromium.googlesource.com/chromium/src/+/HEAD/docs/ios/build_instructions.md
- https://www.wolfcstech.com/2019/03/27/quic_2019_03_27/
- https://www.wolfcstech.com/2017/03/09/QUIC加密协议/
- https://tools.ietf.org/html/rfc1918
- https://github.com/Tencent/mars





